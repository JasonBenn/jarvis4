# Readwise Highlights VS Code Extension - Architecture Plan

## Overview

A VS Code extension that integrates Readwise highlights into the Cursor Compose workflow. The extension provides a sidebar panel for reviewing highlights, with keyboard-driven navigation and actions to integrate highlights into the worldview document.

## High-Level Flow

1. User runs `worldview-update` script
2. Script opens Cursor
3. Script triggers VS Code command to fetch new highlights from Readwise API
4. Extension fetches highlights and stores them in local SQLite database
5. Extension opens sidebar panel showing:
   - New highlights (status = 'NEW')
   - Previously snoozed highlights (snoozed 4+ weeks ago)
6. User navigates highlights with keyboard:
   - **↑/↓**: Navigate between highlights
   - **SPACE**: Expand/collapse full highlight text
   - **ENTER**: Add to worldview prompt + mark as INTEGRATED + remove from view
   - **S**: Snooze (add timestamp to snooze_history, remove from view)
   - **BACKSPACE**: Archive (mark as ARCHIVED, remove from view)
7. Buttons at bottom: "Snooze All" and "Archive All"
8. When ENTER pressed: highlight text appended to `prompts/worldview-update.md` and full prompt pasted into Compose

---

## Architecture Components

### 1. VS Code Extension Structure

```
jarvis4/
  extension/
    jarvis4-worldview-updater/   # Extension source code (generated by yo code)
      package.json               # Extension manifest
      .vscode/
        launch.json              # Debug configuration (auto-generated)
      src/
        extension.ts             # Main activation entry point (scaffolded)
        readwiseClient.ts        # Readwise API client (to add)
        database.ts              # SQLite database manager (to add)
        webview.ts               # Webview panel manager (to add)
        commands.ts              # Command handlers (to add)
      prompts/                   # Prompt templates (moved from jarvis4/prompts/)
        worldview-update.md      # Base prompt template
      media/                     # Webview assets (to add)
        styles.css               # Webview styles
        main.js                  # Webview frontend logic
      resources/                 # Extension icons (to add)
        icons/
      dist/                      # Compiled output from esbuild
      esbuild.js                 # Build configuration (auto-generated)
      tsconfig.json              # TypeScript configuration (auto-generated)
      eslint.config.mjs          # ESLint configuration (auto-generated)
```

**Note**: The extension was scaffolded with `yo code` using:
- Name: `jarvis4-worldview-updater`
- TypeScript
- esbuild bundler
- pnpm package manager

### 2. Database Schema (SQLite in `db/readwise-highlights.db`)

**Design Philosophy**: Keep the database as a minimal state-tracking layer. All highlight content (text, title, author, etc.) is fetched fresh from the Readwise API on each session. The DB only tracks user actions (integrated, archived, snoozed).

```sql
CREATE TABLE highlights (
  id TEXT PRIMARY KEY,              -- Readwise highlight ID
  status TEXT CHECK(status IN ('NEW', 'INTEGRATED', 'ARCHIVED')) DEFAULT 'NEW',

  snooze_history TEXT,              -- JSON array of ISO timestamps
  next_show_date TEXT,              -- ISO date when to show again (null if not snoozed)
                                    -- Computed in TypeScript when snoozed

  first_seen TEXT NOT NULL,         -- When first fetched by extension
  last_updated TEXT NOT NULL        -- Last status change timestamp
);

CREATE INDEX idx_status ON highlights(status);
CREATE INDEX idx_next_show_date ON highlights(next_show_date);
```

**Rationale**:
- No duplication of Readwise data (text, title, author, etc.)
- Extension always fetches fresh highlight content from Readwise API
- Database is only for tracking user state and snooze timestamps
- Simpler, more maintainable code
- Extension requires internet connection anyway (API-dependent)

### 3. Key API Integrations

#### Readwise API

**Endpoint**: `GET https://readwise.io/api/v2/export/`
- **Auth**: `Authorization: Token {READWISE_API_TOKEN}`
- **Params**:
  - `updatedAfter` (ISO timestamp) - fetch only highlights updated since last fetch
  - `pageCursor` - for pagination
- **Response**: Array of highlights with metadata

**TypeScript SDK**: We use the `readwise-reader-api` package (installed via `pnpm add readwise-reader-api`)

```typescript
import { Readwise } from 'readwise-reader-api';
import type { ReadwiseBook, ReadwiseHighlight } from 'readwise-reader-api';

// The SDK exports these types - no need to redefine them!
// - ReadwiseBook
// - ReadwiseBookHighlights
// - ReadwiseHighlight
// - ReadwiseLibraryCategoryType
```

**Usage**:
```typescript
const readwise = new Readwise({
  auth: process.env.READWISE_API_TOKEN
});

// Export highlights (with optional updatedAfter filter)
const data = await readwise.highlights.export({
  updatedAfter: "2024-01-27T00:00:00Z"
});
```

**Response Structure**: The SDK's `ReadwiseBook` and `ReadwiseHighlight` types match the API response structure from `/api/v2/export/`

**Package**: [readwise-reader-api](https://github.com/Scarvy/readwise-reader-api) - Unofficial but well-maintained TypeScript SDK

#### VS Code API Methods

**Extension Activation**:
```typescript
vscode.window.registerTreeDataProvider()  // If using tree view
vscode.window.createWebviewPanel()        // For custom webview sidebar
vscode.commands.registerCommand()         // Register commands
```

**Webview Management**:
```typescript
// Create webview panel
const panel = vscode.window.createWebviewPanel(
  'readwiseHighlights',           // viewType
  'Readwise Highlights',          // title
  vscode.ViewColumn.One,          // column
  {
    enableScripts: true,
    retainContextWhenHidden: true,
    localResourceRoots: [...]
  }
);

// Post messages to webview
panel.webview.postMessage({
  type: 'updateHighlights',
  highlights: [...]
});

// Receive messages from webview
panel.webview.onDidReceiveMessage(message => {
  // Handle actions
});
```

**Prompt Generation & Compose Integration**:
```typescript
// Read the worldview-update prompt template
const promptPath = vscode.Uri.joinPath(
  context.extensionUri,
  'prompts',
  'worldview-update.md'
);
const promptDoc = await vscode.workspace.openTextDocument(promptPath);
const basePrompt = promptDoc.getText();

// Append selected highlight(s) in memory
const highlightText = formatHighlight(highlight);
const fullPrompt = `${basePrompt}\n\n${highlightText}`;

// Insert into Compose via clipboard + keyboard automation
// Note: Cursor Compose has no programmatic API (as of 2025)
const { exec } = require('child_process');
const util = require('util');
const execPromise = util.promisify(exec);

const escapedText = fullPrompt.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
const script = `
  set the clipboard to "${escapedText}"
  tell application "Cursor"
    activate
    delay 0.2
    tell application "System Events"
      keystroke "i" using {command down}  -- Open Compose (Cmd+I)
      delay 0.3
      keystroke "v" using {command down}  -- Paste from clipboard
    end tell
  end tell
`;
await execPromise(`osascript -e '${script}'`);
```

---

## Implementation Details

### 1. Extension Entry Point (`extension.ts`)

```typescript
import * as vscode from 'vscode';
import { HighlightDatabase } from './database';
import { ReadwiseClient } from './readwiseClient';
import { WebviewManager } from './webview';
import { registerCommands } from './commands';

export async function activate(context: vscode.ExtensionContext) {
  // Initialize database (workspace-specific with fallback)
  const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
  const dbPath = workspaceFolder
    ? path.join(workspaceFolder.uri.fsPath, 'db', 'readwise-highlights.db')
    : path.join(context.globalStorageUri.fsPath, 'readwise-highlights.db');

  const db = new HighlightDatabase(dbPath);
  await db.initialize();

  // Initialize Readwise client
  const apiToken = vscode.workspace.getConfiguration('readwise').get<string>('apiToken');
  const readwise = new ReadwiseClient(apiToken);

  // Initialize webview manager
  const webviewManager = new WebviewManager(context, db);

  // Register commands
  registerCommands(context, db, readwise, webviewManager);

  // Store in context for access
  context.subscriptions.push(db);
}
```

### 2. Database Manager (`database.ts`)

```typescript
import * as sqlite3 from 'sqlite3';
import { open, Database } from 'sqlite';

interface HighlightState {
  id: string;
  status: 'NEW' | 'INTEGRATED' | 'ARCHIVED';
  snooze_history: string | null;  // JSON array of ISO timestamps
  next_show_date: string | null;  // ISO date
  first_seen: string;
  last_updated: string;
}

export class HighlightDatabase {
  private db: Database | null = null;

  constructor(private dbPath: string) {}

  async initialize(): Promise<void> {
    this.db = await open({
      filename: this.dbPath,
      driver: sqlite3.Database
    });

    await this.db.exec(`
      CREATE TABLE IF NOT EXISTS highlights (
        id TEXT PRIMARY KEY,
        status TEXT CHECK(status IN ('NEW', 'INTEGRATED', 'ARCHIVED')) DEFAULT 'NEW',
        snooze_history TEXT,
        next_show_date TEXT,
        first_seen TEXT NOT NULL,
        last_updated TEXT NOT NULL
      );

      CREATE INDEX IF NOT EXISTS idx_status ON highlights(status);
      CREATE INDEX IF NOT EXISTS idx_next_show_date ON highlights(next_show_date);
    `);
  }

  async getVisibleHighlightIds(): Promise<string[]> {
    const rows = await this.db!.all<{ id: string }[]>(`
      SELECT id FROM highlights
      WHERE status = 'NEW'
         OR (next_show_date IS NOT NULL AND next_show_date <= datetime('now'))
      ORDER BY first_seen DESC
    `);
    return rows.map(r => r.id);
  }

  async getHighlightState(id: string): Promise<HighlightState | null> {
    return this.db!.get<HighlightState>(
      'SELECT * FROM highlights WHERE id = ?',
      [id]
    );
  }

  async trackHighlight(id: string): Promise<void> {
    const now = new Date().toISOString();

    await this.db!.run(`
      INSERT INTO highlights (id, status, first_seen, last_updated)
      VALUES (?, 'NEW', ?, ?)
      ON CONFLICT(id) DO NOTHING
    `, [id, now, now]);
  }

  async updateStatus(id: string, status: 'INTEGRATED' | 'ARCHIVED'): Promise<void> {
    const now = new Date().toISOString();
    await this.db!.run(
      'UPDATE highlights SET status = ?, last_updated = ? WHERE id = ?',
      [status, now, id]
    );
  }

  async snoozeHighlight(id: string, durationWeeks: number = 4): Promise<void> {
    const state = await this.getHighlightState(id);
    if (!state) return;

    const now = new Date().toISOString();
    const snoozeHistory = state.snooze_history
      ? JSON.parse(state.snooze_history)
      : [];
    snoozeHistory.push(now);

    // Compute next_show_date based on configured duration
    const nextShowDate = new Date();
    nextShowDate.setDate(nextShowDate.getDate() + (durationWeeks * 7));

    await this.db!.run(`
      UPDATE highlights
      SET snooze_history = ?,
          next_show_date = ?,
          last_updated = ?
      WHERE id = ?
    `, [
      JSON.stringify(snoozeHistory),
      nextShowDate.toISOString(),
      now,
      id
    ]);
  }

  dispose(): void {
    this.db?.close();
  }
}
```

### 3. Readwise Client (`readwiseClient.ts`)

**Note**: Using the `readwise-reader-api` SDK instead of implementing our own client.

```typescript
import { Readwise } from 'readwise-reader-api';
import type { ReadwiseBook, ReadwiseHighlight } from 'readwise-reader-api';

export class ReadwiseClient {
  private client: Readwise;

  constructor(apiToken: string) {
    this.client = new Readwise({
      auth: apiToken
    });
  }

  async fetchHighlights(updatedAfter?: string): Promise<ReadwiseBook[]> {
    // The SDK handles pagination automatically
    const response = await this.client.highlights.export({
      updatedAfter
    });

    return response;
  }

  // Helper to get all highlights with their parent book info
  async fetchAllHighlightsWithBooks(updatedAfter?: string): Promise<Array<{
    highlight: ReadwiseHighlight;
    book: ReadwiseBook;
  }>> {
    const books = await this.fetchHighlights(updatedAfter);

    const results: Array<{ highlight: ReadwiseHighlight; book: ReadwiseBook }> = [];

    for (const book of books) {
      for (const highlight of book.highlights) {
        results.push({ highlight, book });
      }
    }

    return results;
  }
}
```

### 4. Webview Manager (`webview.ts`)

```typescript
import * as vscode from 'vscode';
import * as path from 'path';
import { HighlightDatabase } from './database';

export class WebviewManager {
  private panel: vscode.WebviewPanel | undefined;

  constructor(
    private context: vscode.ExtensionContext,
    private db: HighlightDatabase
  ) {}

  async show(): Promise<void> {
    if (this.panel) {
      this.panel.reveal(vscode.ViewColumn.One);
      await this.refresh();
      return;
    }

    this.panel = vscode.window.createWebviewPanel(
      'readwiseHighlights',
      'Readwise Highlights',
      vscode.ViewColumn.One,
      {
        enableScripts: true,
        retainContextWhenHidden: true,
        localResourceRoots: [
          vscode.Uri.file(path.join(this.context.extensionPath, 'media'))
        ]
      }
    );

    this.panel.webview.html = this.getWebviewContent();

    // Handle messages from webview
    this.panel.webview.onDidReceiveMessage(
      async message => {
        switch (message.type) {
          case 'integrate':
            await this.handleIntegrate(message.highlightId);
            break;
          case 'snooze':
            await this.handleSnooze(message.highlightId);
            break;
          case 'archive':
            await this.handleArchive(message.highlightId);
            break;
          case 'snoozeAll':
            await this.handleSnoozeAll();
            break;
          case 'archiveAll':
            await this.handleArchiveAll();
            break;
        }
      },
      undefined,
      this.context.subscriptions
    );

    this.panel.onDidDispose(() => {
      this.panel = undefined;
    });

    await this.refresh();
  }

  async refresh(): Promise<void> {
    if (!this.panel) return;

    const highlights = await this.db.getVisibleHighlights();
    this.panel.webview.postMessage({
      type: 'updateHighlights',
      highlights
    });
  }

  private async handleIntegrate(highlightId: string): Promise<void> {
    // Get highlight data from Readwise (in real implementation,
    // this would come from the full highlight list fetched earlier)
    const highlight = await this.getHighlightData(highlightId);
    if (!highlight) return;

    // Read the worldview-update prompt template (bundled in extension)
    const promptPath = vscode.Uri.joinPath(
      this.context.extensionUri,
      'prompts',
      'worldview-update.md'
    );
    const promptDoc = await vscode.workspace.openTextDocument(promptPath);
    const basePrompt = promptDoc.getText();

    // Build full prompt with highlight appended (in memory only)
    const highlightText = this.formatHighlight(highlight);
    const fullPrompt = `${basePrompt}\n\n${highlightText}`;

    // Update status in DB
    await this.db.updateStatus(highlightId, 'INTEGRATED');

    // Paste to Compose
    await this.pasteToCompose(fullPrompt);

    // Refresh view
    await this.refresh();
  }

  private async handleSnooze(highlightId: string): Promise<void> {
    await this.db.snoozeHighlight(highlightId);
    await this.refresh();
  }

  private async handleArchive(highlightId: string): Promise<void> {
    await this.db.updateStatus(highlightId, 'ARCHIVED');
    await this.refresh();
  }

  private async handleSnoozeAll(): Promise<void> {
    const highlights = await this.db.getVisibleHighlights();
    for (const h of highlights) {
      await this.db.snoozeHighlight(h.id);
    }
    await this.refresh();
  }

  private async handleArchiveAll(): Promise<void> {
    const highlights = await this.db.getVisibleHighlights();
    for (const h of highlights) {
      await this.db.updateStatus(h.id, 'ARCHIVED');
    }
    await this.refresh();
  }

  private formatHighlight(highlight: any): string {
    const source = highlight.source_author
      ? `${highlight.source_title} by ${highlight.source_author}`
      : highlight.source_title || 'Unknown Source';

    return `<highlight>\n${highlight.text}\n— ${source}\n</highlight>`;
  }

  private formatMultipleHighlights(highlights: any[]): string {
    const formatted = highlights
      .map(h => this.formatHighlight(h))
      .join('\n\n');

    return `<highlights>\n${formatted}\n</highlights>`;
  }

  private async pasteToCompose(text: string): Promise<void> {
    // Cursor Compose has no programmatic API (as of 2025)
    // Use clipboard + AppleScript keyboard automation
    const { exec } = require('child_process');
    const util = require('util');
    const execPromise = util.promisify(exec);

    // Escape text for AppleScript string
    const escapedText = text.replace(/\\/g, '\\\\').replace(/"/g, '\\"');

    const script = `
      set the clipboard to "${escapedText}"
      tell application "Cursor"
        activate
        delay 0.2
        tell application "System Events"
          keystroke "i" using {command down}
          delay 0.3
          keystroke "v" using {command down}
        end tell
      end tell
    `;

    try {
      await execPromise(`osascript -e '${script}'`);
    } catch (error) {
      vscode.window.showErrorMessage(`Failed to paste to Compose: ${error}`);
    }
  }

  private getWebviewContent(): string {
    const scriptUri = this.panel!.webview.asWebviewUri(
      vscode.Uri.file(path.join(this.context.extensionPath, 'media', 'main.js'))
    );
    const styleUri = this.panel!.webview.asWebviewUri(
      vscode.Uri.file(path.join(this.context.extensionPath, 'media', 'styles.css'))
    );

    return `<!DOCTYPE html>
    <html lang="en">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <link rel="stylesheet" href="${styleUri}">
      <title>Readwise Highlights</title>
    </head>
    <body>
      <div id="app">
        <div id="highlights-container"></div>
        <div class="actions">
          <button id="snooze-all">Snooze All</button>
          <button id="archive-all">Archive All</button>
        </div>
      </div>
      <script src="${scriptUri}"></script>
    </body>
    </html>`;
  }
}
```

### 5. Webview Frontend (`media/main.js`)

```javascript
(function() {
  const vscode = acquireVsCodeApi();
  let highlights = [];
  let selectedIndex = 0;
  let expandedIds = new Set();

  window.addEventListener('message', event => {
    const message = event.data;
    if (message.type === 'updateHighlights') {
      highlights = message.highlights;
      render();
    }
  });

  function render() {
    const container = document.getElementById('highlights-container');
    container.innerHTML = highlights.map((h, i) => {
      const isSelected = i === selectedIndex;
      const isExpanded = expandedIds.has(h.id);
      const preview = h.text.slice(0, 100) + (h.text.length > 100 ? '...' : '');
      const fullText = h.text;
      const source = h.source_author
        ? `${h.source_title} by ${h.source_author}`
        : h.source_title || 'Unknown';
      const date = h.highlighted_at
        ? new Date(h.highlighted_at).toLocaleDateString()
        : '';
      const snoozeCount = h.snooze_count > 0 ? `(Snoozed ${h.snooze_count}x)` : '';

      return `
        <div class="highlight ${isSelected ? 'selected' : ''}" data-index="${i}">
          <div class="highlight-header">
            <div class="highlight-source">${source} ${snoozeCount}</div>
            <div class="highlight-date">${date}</div>
          </div>
          <div class="highlight-text">
            ${isExpanded ? fullText : preview}
          </div>
        </div>
      `;
    }).join('');

    // Scroll selected into view
    const selectedEl = container.querySelector('.selected');
    if (selectedEl) {
      selectedEl.scrollIntoView({ block: 'nearest' });
    }
  }

  // Keyboard navigation
  document.addEventListener('keydown', e => {
    if (highlights.length === 0) return;

    switch(e.key) {
      case 'ArrowUp':
        e.preventDefault();
        selectedIndex = Math.max(0, selectedIndex - 1);
        render();
        break;
      case 'ArrowDown':
        e.preventDefault();
        selectedIndex = Math.min(highlights.length - 1, selectedIndex + 1);
        render();
        break;
      case ' ':
        e.preventDefault();
        const id = highlights[selectedIndex].id;
        if (expandedIds.has(id)) {
          expandedIds.delete(id);
        } else {
          expandedIds.add(id);
        }
        render();
        break;
      case 'Enter':
        vscode.postMessage({
          type: 'integrate',
          highlightId: highlights[selectedIndex].id
        });
        break;
      case 's':
      case 'S':
        vscode.postMessage({
          type: 'snooze',
          highlightId: highlights[selectedIndex].id
        });
        break;
      case 'Backspace':
        vscode.postMessage({
          type: 'archive',
          highlightId: highlights[selectedIndex].id
        });
        break;
    }
  });

  // Button handlers
  document.getElementById('snooze-all').addEventListener('click', () => {
    vscode.postMessage({ type: 'snoozeAll' });
  });

  document.getElementById('archive-all').addEventListener('click', () => {
    vscode.postMessage({ type: 'archiveAll' });
  });
})();
```

### 6. Commands (`commands.ts`)

```typescript
import * as vscode from 'vscode';
import { HighlightDatabase } from './database';
import { ReadwiseClient } from './readwiseClient';
import { WebviewManager } from './webview';

export function registerCommands(
  context: vscode.ExtensionContext,
  db: HighlightDatabase,
  readwise: ReadwiseClient,
  webview: WebviewManager
) {
  // Main command: fetch and show
  context.subscriptions.push(
    vscode.commands.registerCommand('readwise.fetchAndShow', async () => {
      await vscode.window.withProgress({
        location: vscode.ProgressLocation.Notification,
        title: 'Fetching Readwise highlights...',
        cancellable: false
      }, async (progress) => {
        try {
          // Get last fetch time from workspace state
          const lastFetch = context.workspaceState.get<string>('lastReadwiseFetch');

          // Fetch highlights
          const books = await readwise.fetchHighlights(lastFetch);

          // Store in database
          let count = 0;
          for (const book of books) {
            for (const highlight of book.highlights) {
              await db.upsertHighlight({
                id: String(highlight.id),
                text: highlight.text,
                source_title: book.title,
                source_author: book.author,
                source_type: book.category,
                highlighted_at: highlight.highlighted_at,
                note: highlight.note,
                url: highlight.url || book.source_url,
                status: 'NEW',
                first_seen: new Date().toISOString()
              });
              count++;
            }
          }

          // Update last fetch time
          await context.workspaceState.update('lastReadwiseFetch', new Date().toISOString());

          // Show webview
          await webview.show();

          vscode.window.showInformationMessage(`Fetched ${count} highlights from Readwise`);
        } catch (error) {
          vscode.window.showErrorMessage(`Error fetching highlights: ${error}`);
        }
      });
    })
  );

  // Command to just show panel (without fetching)
  context.subscriptions.push(
    vscode.commands.registerCommand('readwise.showPanel', async () => {
      await webview.show();
    })
  );
}
```

### 7. Extension Manifest (`package.json`)

```json
{
  "name": "readwise-highlights",
  "displayName": "Readwise Highlights",
  "description": "Integrate Readwise highlights into Cursor Compose workflow",
  "version": "0.1.0",
  "publisher": "jasonbenn",
  "engines": {
    "vscode": "^1.85.0"
  },
  "categories": ["Other"],
  "activationEvents": [
    "onCommand:readwise.fetchAndShow"
  ],
  "main": "./out/extension.js",
  "contributes": {
    "commands": [
      {
        "command": "readwise.fetchAndShow",
        "title": "Fetch and Show Readwise Highlights"
      },
      {
        "command": "readwise.showPanel",
        "title": "Show Readwise Highlights Panel"
      }
    ],
    "configuration": {
      "title": "Readwise Highlights",
      "properties": {
        "readwise.apiToken": {
          "type": "string",
          "default": "",
          "description": "Your Readwise API token"
        },
        "readwise.snoozeDurationWeeks": {
          "type": "number",
          "default": 4,
          "description": "Number of weeks to snooze a highlight (default: 4)",
          "minimum": 1
        }
      }
    }
  },
  "scripts": {
    "vscode:prepublish": "npm run compile",
    "compile": "tsc -p ./",
    "watch": "tsc -watch -p ./",
    "pretest": "npm run compile"
  },
  "devDependencies": {
    "@types/node": "^18.x",
    "@types/vscode": "^1.85.0",
    "typescript": "^5.3.0"
  },
  "dependencies": {
    "sqlite": "^5.1.1",
    "sqlite3": "^5.1.7",
    "readwise-reader-api": "^0.5.2"
  }
}
```

---

## Development Workflow

### Initial Setup ✅ COMPLETED

The extension has been scaffolded with:
```bash
cd jarvis4/extension
npx --package yo --package generator-code -- yo code
```

Choices made:
- Type: **New Extension (TypeScript)**
- Name: `jarvis4-worldview-updater`
- Identifier: `jarvis4-worldview-updater`
- Description: (empty)
- Initialize git: No (already in parent repo)
- Bundler: **esbuild**
- Package manager: **pnpm**

Generated structure includes:
- `package.json` with basic extension manifest
- `.vscode/launch.json` for F5 debugging
- `src/extension.ts` with sample "Hello World" command
- `esbuild.js` for bundling configuration
- TypeScript and ESLint configuration

### Daily Development

1. **Open extension folder in Cursor**:
   ```bash
   cursor jarvis4/extension/jarvis4-worldview-updater
   ```

2. **Press F5** (or Cmd+Shift+D → "Run Extension"):
   - This launches an **Extension Development Host** - a new Cursor window with your extension loaded
   - All console.log output appears in the Debug Console of the main window
   - Set breakpoints in your TypeScript code for debugging

3. **Make changes → Reload**:
   - Edit code in main Cursor window
   - In Extension Development Host window: Cmd+R (Developer: Reload Window) to reload the extension
   - Or restart debugging from main window

4. **The `.vscode/launch.json`** is auto-created and looks like:
   ```json
   {
     "version": "0.2.0",
     "configurations": [
       {
         "name": "Run Extension",
         "type": "extensionHost",
         "request": "launch",
         "runtimeExecutable": "${execPath}",
         "args": ["--extensionDevelopmentPath=${workspaceFolder}"],
         "outFiles": ["${workspaceFolder}/out/**/*.js"]
       }
     ]
   }
   ```

### Installing for Production Use

When ready to use the extension normally (not just for testing):

```bash
cd jarvis4/extension/jarvis4-worldview-updater
npx vsce package                    # Creates jarvis4-worldview-updater-0.0.1.vsix
cursor --install-extension jarvis4-worldview-updater-0.0.1.vsix
```

After installation, the extension loads automatically when Cursor starts.

---

## Integration with `worldview-update` Script

The `worldview-update` script triggers the extension command in an already-running Cursor instance:

```bash
#!/bin/bash

# Open Cursor (if not already open)
open -a Cursor

# Wait for Cursor to fully launch
sleep 2

# Trigger the command via CLI
cursor --command readwise.fetchAndShow

# Alternative: Use AppleScript to trigger command palette
# osascript -e 'tell application "Cursor" to activate' \
#   -e 'tell application "System Events" to keystroke "p" using {command down, shift down}' \
#   -e 'delay 0.5' \
#   -e 'tell application "System Events" to keystroke "Readwise: Fetch and Show Highlights"' \
#   -e 'tell application "System Events" to key code 36'  # Enter key
```

**Important**: The extension must be installed first (via `.vsix` package) for this to work in production. During development, you'd manually run the command from the Extension Development Host.

---

## UI/UX Specifications

### Highlight Display Format

```
┌─────────────────────────────────────────────┐
│ [Source Title] by [Author] (Snoozed 2x)     │
│ [Date Created]                              │
│                                             │
│ [First 100 chars of highlight...]          │
└─────────────────────────────────────────────┘
```

When expanded (SPACE pressed):
```
┌─────────────────────────────────────────────┐
│ [Source Title] by [Author] (Snoozed 2x)     │
│ [Date Created]                              │
│                                             │
│ [Full highlight text, wrapped to container  │
│  width, can be multiple lines]              │
└─────────────────────────────────────────────┘
```

### Keyboard Shortcuts
- **↑/↓**: Navigate highlights
- **SPACE**: Toggle expand/collapse + select (multi-select supported)
- **ENTER**: Integrate selected highlight(s) (append to prompt, mark as integrated, paste to Compose)
- **S**: Snooze (add to snooze history, hide for configured duration)
- **BACKSPACE**: Archive (mark as archived, remove from view)

### Multi-Select Behavior
- Press SPACE to expand/collapse and toggle selection
- Selected highlights show visual indicator
- Can select multiple highlights before pressing ENTER
- ENTER processes all selected highlights together

### Bottom Actions
- **[Snooze All]** button - snoozes all visible highlights
- **[Archive All]** button - archives all visible highlights

---

## Implementation Checklist

- [ ] Initialize VS Code extension project structure
- [ ] Set up TypeScript compilation
- [ ] Create SQLite database schema and manager
- [ ] Implement Readwise API client
- [ ] Build webview HTML/CSS/JS
- [ ] Implement keyboard navigation in webview
- [ ] Create command handlers
- [ ] Implement highlight integration logic (append + paste)
- [ ] Test snooze/archive functionality
- [ ] Create AppleScript fallback for Compose integration
- [ ] Update worldview-update script
- [ ] Add configuration for API token
- [ ] Test end-to-end flow
- [ ] Add error handling and logging
- [ ] Write user documentation

---

## Open Questions / Decisions Needed

1. **Delimiter for multiple highlights**: ✅ **XML format**
   ```xml
   <highlights>
     <highlight>
     Highlight text 1
     — Source 1
     </highlight>

     <highlight>
     Highlight text 2
     — Source 2
     </highlight>
   </highlights>
   ```

2. **Compose integration method**:
   - ✅ **AppleScript only** - Cursor Compose has no programmatic API (researched and confirmed)
   - Uses clipboard + keyboard automation (Cmd+I to open, Cmd+V to paste)
   - Community has requested API access but feature doesn't exist yet

3. **API Token storage**:
   - Store in VS Code settings (insecure but convenient)
   - Alternative: VS Code secrets API for secure storage

4. **Snooze duration**: ✅ **Configurable setting**
   - Setting: `readwise.snoozeDurationWeeks` (default: 4)
   - User can customize in VS Code settings

5. **Database location**: ✅ **Workspace-specific with fallback**
   - Primary: `${workspaceFolder}/db/readwise-highlights.db`
   - Fallback: `${context.globalStorageUri}/readwise-highlights.db` (if no workspace)
   - Benefits:
     - Works from any workspace (open-source friendly)
     - User can track different highlights per project if desired
     - Portable - DB lives with the workspace
   - For your use case: Will automatically use `~/notes/Neighborhood\ Notes/db/`

---

## Future Enhancements

1. **Search/Filter**: Add search box to filter highlights by text or source
2. **Tags**: Support Readwise tags for organization
3. **Custom snooze durations**: Allow user to choose snooze period
4. **Bulk operations**: Select multiple highlights for batch actions
5. **Statistics**: Show stats (total highlights, integration rate, etc.)
6. **Export**: Export highlights to markdown/JSON
7. **Sync status back to Readwise**: Update Readwise with integrated/archived status via tags
